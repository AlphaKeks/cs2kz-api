//! Everything related to authenticating CS2 servers.

use std::time::Duration;

use axum::response::{IntoResponse, Response};
use derive_more::{Debug, Display, Into};
use serde::{Deserialize, Serialize};
use sqlx::database::{HasArguments, HasValueRef};
use sqlx::encode::IsNull;
use sqlx::error::BoxDynError;
use utoipa::ToSchema;
use uuid::Uuid;

use super::Jwt;
use crate::plugin::PluginVersionID;
use crate::servers::ServerID;
use crate::{Result, State};

/// An authenticated CS2 server.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, ToSchema)]
pub struct Server {
	/// The server's ID.
	id: ServerID,

	/// The ID of the cs2kz plugin version the server is currently running.
	plugin_version_id: PluginVersionID,
}

impl Server {
	/// Creates a new [`Server`] object.
	pub const fn new(id: ServerID, plugin_version_id: PluginVersionID) -> Self {
		Self {
			id,
			plugin_version_id,
		}
	}

	/// Returns the server's ID.
	pub const fn id(&self) -> ServerID {
		self.id
	}

	/// Returns the server's plugin version ID.
	pub const fn plugin_version_id(&self) -> PluginVersionID {
		self.plugin_version_id
	}
}

/// Refresh Key for authentication.
///
/// CS2 servers use this key to generate `Token`s, which can then be used in requests to protected
/// endpoints.
///
/// This key is "permanent", i.e. has no expiration date. It can however be re-generated by admins
/// and server owners at will.
#[derive(Debug, Display, Clone, Copy, Into, Serialize, Deserialize, ToSchema)]
#[debug("*****")]
#[display("{_0}")]
pub struct Key(Uuid);

impl Key {
	/// Generates a new key.
	pub fn new() -> Self {
		Self(Uuid::new_v4())
	}
}

impl<DB> sqlx::Type<DB> for Key
where
	DB: sqlx::Database,
	uuid::fmt::Hyphenated: sqlx::Type<DB>,
{
	fn type_info() -> <DB as sqlx::Database>::TypeInfo {
		<uuid::fmt::Hyphenated as sqlx::Type<DB>>::type_info()
	}
}

impl<'q, DB> sqlx::Encode<'q, DB> for Key
where
	DB: sqlx::Database,
	uuid::fmt::Hyphenated: sqlx::Encode<'q, DB>,
{
	fn encode_by_ref(&self, buf: &mut <DB as HasArguments<'q>>::ArgumentBuffer) -> IsNull {
		self.0.as_hyphenated().encode_by_ref(buf)
	}
}

impl<'r, DB> sqlx::Decode<'r, DB> for Key
where
	DB: sqlx::Database,
	uuid::fmt::Hyphenated: sqlx::Decode<'r, DB>,
{
	fn decode(value: <DB as HasValueRef<'r>>::ValueRef) -> Result<Self, BoxDynError> {
		<uuid::fmt::Hyphenated as sqlx::Decode<'r, DB>>::decode(value)
			.map(Uuid::from)
			.map(Self)
	}
}

/// Access token for CS2 servers.
///
/// These expire after 15 minutes and can be used in requests for accessing protected routes.
#[derive(Debug, Into, Serialize, Deserialize, ToSchema)]
pub struct Token(String);

impl Token {
	/// Generate a new [`Token`] for the given `server`.
	pub fn new(server: &Server, state: &State) -> Result<Self> {
		let expires_after = Duration::from_secs(60 * 15);
		let jwt = Jwt::new(server, expires_after);
		let jwt = state.encode_jwt(jwt)?;

		Ok(Self(jwt))
	}
}

impl IntoResponse for Token {
	fn into_response(self) -> Response {
		self.0.into_response()
	}
}
